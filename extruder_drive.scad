/* extruder_drive.scad is a derivative of the MOST extruder drive {{{
Copyright (C) 2015 Gerald Anzalone
Copyright (C) 2017 Bas Wijnen <info@zelfmaker.nl>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with this program. If not, see <http://www.gnu.org/licenses/>.

MOST extruder drive derived from:
  Airtripper's Bowden 3D Printer Extruder Revision 3
  by Airtripper May  ï¿½ 2012
  airtripper.com

  }}} */
// includes may be downloaded from https://github.com/phidiasllc/scad_libraries

function dist(a, b) = sqrt(pow(a[0] - b[0], 2) + pow(a[1] - b[1], 2));

// Includes and variables. {{{
include <include/fasteners.scad>
include <include/bearings.scad>
include <include/steppers.scad>
include <include/threads.scad>

$fn = 48;

// The layer height while printing, for generating single-layer floors.
layer_height = .3;

wall = 5;
top_wall = 1;

// not all drive gears are created equally, set drive gear dimensions here:
d_gear = 12.0; // diameter of the drive gear - original mk7 drive gear = 12.7
d_hob = 10.3; // diameter of the hobbed portion of the drive gear - original mk7 drive gear = 11.3
r_teeth = .7; // distance that filament sinks into the teeth of the gear

d_top_bearing = 16;	// Bearing on top of the drive gear.
h_top_bearing = 5;	// Bearing on top of the drive gear.

l_screw = 30;	// Length of screws that are used.
l_motor_screw = 5;	// Length of screw that fits into motor (a little more is possible).

h_strut = 6;	// Height of support strut.
d_axle = 8;

// following set the dimensions for a given filament [d_sheath, d_filament]
filament300 = [6.55, 3.4];
filament175 = [4.5, 2.1];
filament = filament175; // set to one of the two, above

d_sheath = filament[0];
d_filament = filament[1];
offset_filament = d_hob / 2 + d_filament / 2 - r_teeth;

// Bowden sheath quick release fitting dims
d_quickrelease_threads = 6.5; // M6 threads, but this gives best fit
l_quickrelease_threads = 5; // length of threads on quick release
pitch_quickrelease_threads = 1;


t_feet = 5; // thickness of the mounting feet
t_thin_base = 2; // thickness of the extruder block's back plate
t_base = 4.7; // thickness of the extruder block's back plate

// rather than rewrite everything (should do that anyway) the following is a total hack
l_motor = 21;	// Length of motor shaft.
h_bearing = 5;	// Height of bearing at top of motor.
z_bearing = l_motor - h_bearing; // Base height of bearing at top of motor.
z_filament = z_bearing - 4;	// Height of filament path.
cc_idler_screws = h_608 + d_M3_screw + 2;
a_idler = 45;
v_width = 70.3;	// Copied from value generated by minerva.scad.

// Idler computations.
b = dist([cc_NEMA17_mount / 2, -cc_NEMA17_mount / 2], [offset_filament - d_filament / 2, 0]);
delta = asin((od_608 / 2) / b);
alpha = delta - atan((cc_NEMA17_mount / 2 - (offset_filament - d_filament / 2)) / (cc_NEMA17_mount / 2));

idler_wall = 2.5;
idler_spacer = 1;
l_idler = h_608 + 2 * (idler_spacer + idler_wall);
z_hook = 6;
// }}}

module axle_8mm() { // {{{
	union() {
		cylinder(h = l_idler - idler_wall, d = d_axle - .4);
		// Support flange while printing
		for (i = [0, 90]) {
			rotate([0, 0, i]) {
				translate([0, 0, .5])
					cube([10,1,1], center = true);
			}
		}
		difference() {
			cylinder(h = 1, d = 2 * d_axle);
			translate([0, 0, -1])
				cylinder(h = 3, d = d_axle + 2);
		}
	}
} // }}}

module extruder_idler_608z(preview = false) { // {{{
	translate(preview ? [0, 15.5, -6] : [0, 0, 0]) {
		difference() {
			union() {
				// Show bearing in preview.
				if (preview)
					%translate([0,0,6]) rotate([0,90,0]) cylinder(h = h_608, d = od_608, center = true);
				difference() {
					union() {
						// Base plate for better printing.
						if (!preview) {
							translate([0, 0, layer_height / 2])
								cube([l_idler * 2, cc_NEMA17_mount / 2 + z_hook + od_608 / 3 + l_idler, layer_height], center = true);
						}
						// Bearing holder.
						translate([0, -(cc_NEMA17_mount / 2 + z_hook + od_608 / 3) / 2 + od_608 / 3, 7])
							cube([l_idler, cc_NEMA17_mount / 2 + z_hook + od_608 / 3, 14], center = true);
						// Spring mount.
						translate([0, -cc_NEMA17_mount / 2, z_hook]) {
							rotate([-alpha, 0, 0]) {
								translate([0, cc_NEMA17_mount, 0]) {
									rotate([-a_idler, 0, 0]) {
										translate([0, -7 / 2 - 6, 0]) {
											union() {
												translate([0, 0, 0])
													cube([l_idler, 7, 16], center = true);
												translate([0, 1, 10])
													cube([cc_idler_screws - d_M3_screw, 5, 16], center = true);
											}
										}
									}
								}
							}
						}
					}
					// Bearing housing
					translate([0,0,1])
						cube([l_idler - 2 * idler_wall, 24, 10], center = true);
					translate([0, 0, 6]) {
						rotate([0, 90, 0])
							cylinder(h = l_idler - 2 * idler_wall, d = od_608 + 2, center = true);
					}
				}
				// Axle spacer
				translate([0, 0, 6]) {
					rotate([0, 90, 0])
						cylinder(h = l_idler - idler_wall, d = id_608 + 4, center = true);
				}
				translate([0, 0, 3])
					cube([l_idler - idler_wall, 12, 6], center = true);
			}
			// Bearing axle cut-out
			translate([0, 0, 6]) rotate([0,90,0]) cylinder(l_idler - idler_wall, d = d_axle + .5, center = true);
			translate([0, 0, 2]) cube([l_idler - idler_wall, d_axle + .5, 8], center = true);
			translate([-3.6, 0, 6]) rotate([0,90,0]) cylinder(7.2, d = od_608 + 2);
			// hook
			translate([-9, -15.5, 6]) rotate([0,90,0]) cylinder(22, d = d_M3_screw + 1);
			translate([0, (d_M3_screw + 1) / 2 - 5 - 15.5, 11]) cube([22,10,10], center = true);
			translate([0, -21, 0]) rotate([45,0,0]) cube([24,6,10], center = true);
		}
	}
} // }}}

module drive_body(threads = true) { // {{{
	r_mounts = r_mounts(cc_NEMA17_mount);

	union() {
		%translate([cc_NEMA17_mount / 2, -cc_NEMA17_mount / 2, z_filament]) {
			rotate([0, 90, -alpha]) {
				extruder_idler_608z(preview = true);
			}
		}

		difference() {
			union() {
				// Extruder base
				difference() {
					hull() {
						for(i = [1:4]) {
							rotate([0, 0, i * 90 + 45])
								translate([r_mounts, 0, 0])
									cylinder(d = 12, h = t_base);
						}
					}

					// Thin the base on the side opposite the preload idler
					translate([-45, -25, t_thin_base])
						cube([50, 50, t_base]);
				}

				// webs for bearing housing support
				translate([0, 0, z_bearing + h_bearing / 2]) {
					for (i = [-1, 1]) {
						rotate([0, 0, i * 45]) {
							hull() {
								translate([-6, 0, 0])
									cylinder(d = 4, h = h_bearing / 2);

								translate([-r_mounts, 0, 0])
									cylinder(d = 9, h = h_bearing / 2);
							}
						}
					}
				}

				bearing_housing_body();

				filament_path(threads = threads);

				// M3 Screw columns for stepper attachment
				translate([-cc_NEMA17_mount / 2, cc_NEMA17_mount / 2, t_thin_base / 2])
					cylinder(r = 4.5, h = l_screw - t_thin_base / 2 - l_motor_screw - h_strut / 2);
				translate([-cc_NEMA17_mount / 2, -cc_NEMA17_mount / 2, t_thin_base / 2])
					cylinder(r = 4.5, h = l_screw - t_thin_base / 2 - l_motor_screw - h_strut / 2);
				translate([cc_NEMA17_mount / 2, cc_NEMA17_mount / 2, t_thin_base / 2])
					cylinder(d = 12, h = l_screw - t_thin_base / 2 - l_motor_screw - h_strut / 2);

				// Idler clamp.
				translate([cc_NEMA17_mount / 2, cc_NEMA17_mount / 2, 0]) {
					rotate([0, 0, a_idler]) {
						translate([9, 0, (l_screw - l_motor_screw - h_strut / 2) / 2])
							cube([18, 12, l_screw - l_motor_screw - h_strut / 2], center = true);
					}
				}

				if (t_feet > 0)
					mounting_feet(thickness = t_feet); // make it 10 for a prusa top mount

				// Support link for outlet.
				hull() {
					for (i = [-1, 1]) {
						translate([i * cc_NEMA17_mount / 2, cc_NEMA17_mount / 2, l_screw - l_motor_screw - h_strut])
							cylinder(d = 9, h = h_strut);
					}
				}
			} // End union.

			bearing_housing_relief();

			// M3 screw holes
			for (r = [1:4]) {
				rotate([0, 0, r * 360 / 4]) {
					translate([cc_NEMA17_mount / 2, cc_NEMA17_mount / 2, -1])
						cylinder(d = d_M3_screw, h = 40);
				}
			}
			// Idler spring M3 screw holes.
			for (z = [-1, 1]) {
				translate([cc_NEMA17_mount / 2, cc_NEMA17_mount / 2, z_filament + z * cc_idler_screws / 2])
					rotate([90, 0, a_idler]) {
						translate([12, 0, 0]) {
							translate([0, 0, -6 - 1])
								cylinder(d = d_M3_nut, h = h_M3_nut + 1, $fn = 6);
							cylinder(d = d_M3_screw, h = 14, center = true);
						}
					}
			}

			// relief for motor collar
			translate([0, 0, -1])
				cylinder(d = d_NEMA17_collar, h = t_base - layer_height + 1);

			// relief for idler - assume it crushes the filament only a small amount - originally 5.5
			// the hobbed portion of the drive gear has a radius about 0.85mm smaller than the od of the gear
			translate([od_608 / 2 + offset_filament, 0, z_filament])
				cylinder(d = od_608, h = h_608 * 1.5, center = true);

			// Drive gear.
			translate([0, 0, t_base - layer_height - 1]) {
				cylinder(d = d_gear + 1, h = z_bearing + h_bearing + top_wall + 2);
				difference() {
					cylinder(d1 = d_NEMA17_collar, d2 = d_gear, h = (z_filament - t_base) / 2 + 1);
					translate([(d_gear + 1) / 2, -cc_NEMA17_mount / 2, -1])
						cube([cc_NEMA17_mount, cc_NEMA17_mount, z_filament]);
				}
			}
		}
	}
} // }}}

module bearing_housing_body() { // {{{
	difference() {
		union() {
			translate([0, 0, .1])
				cylinder(d1 = d_NEMA17_collar + 2 * wall, d2 = d_top_bearing, h = z_bearing + h_bearing - .1 + top_wall);

		}

		for (i = [-1, 1])
			rotate([0, 0, i * 30.5 - 90])
				translate([-cc_NEMA17_mount, 0, -1])
					cube([2 * cc_NEMA17_mount, cc_NEMA17_mount, z_bearing + h_bearing + top_wall + 2]);
	}
} // }}}

module bearing_housing_relief() { // {{{
	difference() {
		union() {
			translate([0, 0, -.1])
				cylinder(d1 = d_NEMA17_collar + wall, d2 = d_top_bearing - wall, h = z_bearing + h_bearing + .1);

			translate([0, 0, z_bearing])
				cylinder(d = d_top_bearing, h = h_top_bearing);

			translate([0, 0, z_bearing + h_bearing - .1])
				cylinder(d1 = d_top_bearing, d2 = d_top_bearing - 2, h = 2.2);
		}
		// Don't cut out the filament path.
		translate([cc_NEMA17_mount / 2, 0, (z_bearing + h_bearing + top_wall) / 2 - 1])
			cube([cc_NEMA17_mount, cc_NEMA17_mount, z_bearing + h_bearing + top_wall + 2], center = true);
	}
} // }}}

module filament_path(threads) { // {{{
	difference() {
		union() {
			// Main body.
			translate([offset_filament, 0, (z_bearing + top_wall) / 2])
				cube([8.1, cc_NEMA17_mount + 22, z_bearing + top_wall], center = true);

			translate([offset_filament, (cc_NEMA17_mount + 12) / 2, (z_filament + d_quickrelease_threads) / 2])
				cube([d_quickrelease_threads + wall, l_quickrelease_threads * 2, z_filament + d_quickrelease_threads / 2], center = true);
		}

		// Cut off for idler block.
		translate([cc_NEMA17_mount / 2 - 6.5, -cc_NEMA17_mount, -1])
			cube([cc_NEMA17_mount, cc_NEMA17_mount, z_bearing + h_top_bearing]);

		// Round sides.
		for (i = [-1, 1]) {
			translate([offset_filament, i * (cc_NEMA17_mount + 25 + 12) / 2, -5]) {
				rotate([0, 90, 0])
					cylinder(d = 25, h = 20, center = true);
			}
		}

		// Top bearing.
		translate([0, 0, z_bearing])
			cylinder(d = d_top_bearing, h = h_top_bearing);

		// filament path
		translate([offset_filament, 0, z_filament]) {
			rotate([90,0,0])
				cylinder(d = d_filament, h = cc_NEMA17_mount * 2, $fn=25, center = true);
		}

		// cone opening at inlet to help guide filament into inlet filament path
		translate([offset_filament, -(cc_NEMA17_mount + 22) / 2 + 3, z_filament]) {
			rotate([90,0,0])
				cylinder(d1 = d_filament, d2 = d_filament * 2, h = 6, $fn=25);
		}

		// Thread for quick connect.
		translate([offset_filament, (cc_NEMA17_mount + 12) / 2, z_filament]) {
			rotate([-90, 0, 0]) {
				if (threads)
					metric_thread(diameter = d_quickrelease_threads, pitch = pitch_quickrelease_threads, length = l_quickrelease_threads + 1, internal = true, n_starts = 1);
				else
					cylinder(d = d_quickrelease_threads - .1, h = l_quickrelease_threads + 1);
			}
		}
	}
} // }}}

module mounting_feet(thickness) { // {{{
	difference() {
		intersection() {
			union() {
				for (i = [-1, 1]) {
					translate([-18.5 - thickness / 2, i * 26, 10])
						cube([thickness, 22, 20], center = true);
				}
			}
			translate([0, 0, 10])
				rotate([45, 0, 0])
					cube(55, center = true);
		}

		// fixing plate cutout
		translate([-20, 0, 12])
			cube([6, 30, 18], center = true);

		// mount holes
		for (i = [-1, 1])
			translate([-23, i * 60 / 2, 10])
				rotate([0, 90, 0])
					cylinder(d = d_M3_screw, h = 30, center = true);
	}
} // }}}

module support_strut() { // {{{

	difference() {
		union() {
			translate([-15.5,0,0]) cylinder(h_strut, r=5, $fn=30);
			translate([15.5,0,0]) cylinder(h_strut, r=5, $fn=30);
			translate([-15.5,-3.5,0]) cube([31,7,h_strut]);
		}
		union() {
			// Screw holes
			for (x = [-1, 1]) {
				translate([x * 15.5, 0, -1]) cylinder(h_strut + 2, d = d_M3_screw);
				translate([x * 15.5, 0, h_strut / 2]) cylinder(h_strut, d = d_M3_cap);
			}
		}
	}
} // }}}

// vim: set filetype=c foldmethod=marker :
